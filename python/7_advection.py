# -*- coding: utf-8 -*-

""" Hyperbolic equations. Advection.

    This program solves the advection equation by applying various methods:
    FTCS, Lax-Wendroff, and Lax-Friedrich and generates an animated plot
    showing the solutions generated by each one of them for certain initial
    conditions.
"""

import argparse

import matplotlib.animation
import matplotlib.pyplot as plt
import numpy as np
import scipy.interpolate

def ftcs(
        u: np.array,
        c: float
) -> np.array:

    """ TODO: FTCS solver.

    Args:
        u: TODO.
        c: Courant number.

    Returns:
        TODO.
    """

    u[1:-1] = (1-c)*u[1:-1] + c*u[:-2]
    return u[1:-1]

def lax_wendroff(
        u: np.array,
        c: float
) -> np.array:

    """ TODO: Lax-Wendroff solver.

    Args:
        u: TODO.
        c: Courant number.

    Returns:
        TODO.
    """

    u[1:-1] = c/2.0*(1+c)*u[:-2] + (1-c**2)*u[1:-1] - c/2.0*(1-c)*u[2:]
    return u[1:-1]

def lax_friedrich(
        u: np.array,
        c: float
) -> np.array:

    """ TODO: Lax-Friedrich solver.

    Args:
        u: TODO.
        c: Courant number.

    Returns:
        TODO.
    """

    u[1:-1] = (u[:-2] +u[2:])/2.0 -  c*(u[2:] - u[:-2])/2.0
    return u[1:-1]

# ##############################################################################

if __name__ == "__main__":

    # Argument parsing ---------------------------------------------------------

    PARSER = argparse.ArgumentParser(description="Advection equation solver")
    PARSER.add_argument("--a", type=float, default=1.0, help="Wave speed")
    PARSER.add_argument("--tmin", type=float, default=0.0, help="Start time")
    PARSER.add_argument("--tmax", type=float, default=4.0, help="End time")
    PARSER.add_argument("--xmin", type=float, default=0.0, help="Spatial start")
    PARSER.add_argument("--xmax", type=float, default=4.0, help="Spatial end")
    PARSER.add_argument("--nx", type=int, default=80, help="Spatial points")
    PARSER.add_argument("--c", type=float, default=0.99, help="Courant number")
    ARGS = PARSER.parse_args()

    A = ARGS.a
    T_MIN = ARGS.tmin
    T_MAX = ARGS.tmax
    X_MIN = ARGS.xmin
    X_MAX = ARGS.xmax
    NX = ARGS.nx
    C = ARGS.c

    LNWDT=2; FNT=15
    plt.rcParams['lines.linewidth'] = LNWDT; plt.rcParams['font.size'] = FNT

    init_func=1   # Select stair case function (0) or sin^2 function (1)

    # function defining the initial condition
    if (init_func==0):
        def f(x):
            f = np.zeros_like(x)
            f[np.where(x <= 0.1)] = 1.0
            return f
    elif(init_func==1):
        def f(x):
            f = np.zeros_like(x)
            x_left = 0.25
            x_right = 0.75
            xm = (x_right-x_left)/2.0
            f = np.where((x>x_left) & (x<x_right), np.sin(np.pi*(x-x_left)/(x_right-x_left))**4,f) 
            return f

    # Discretize
    x = np.linspace(xmin, xmax, Nx+1) # discretization of space
    dx = float((xmax-xmin)/Nx) # spatial step size
    dt = c/a*dx # stable time step calculated from stability requirement
    Nt = int((tmax-tmin)/dt) # number of time steps
    time = np.linspace(tmin, tmax, Nt) # discretization of time

    # solve from tmin to tmax
    solvers = [ftcs, lax_friedrich, lax_wendroff]

    u_solutions=np.zeros((len(solvers),len(time),len(x)))
    uanalytical = np.zeros((len(time), len(x))) # holds the analytical solution


        
    for k, solver in enumerate(solvers): # Solve for all solvers in list
        u = f(x)
        un = np.zeros((len(time), len(x))) # holds the numerical solution

        for i, t in enumerate(time[1:]):
            
            if k==0:
                uanalytical[i,:] = f(x-a*t) # compute analytical solution for this time step
                
            u_bc = scipy.interpolate.interp1d(x[-2:], u[-2:]) # interplate at right bndry
            
            u[1:-1] = solver(u[:], c) # calculate numerical solution of interior
            u[-1] = u_bc(x[-1] - a*dt) # interpolate along a characteristic to find the boundary value
            
            un[i,:] = u[:] # storing the solution for plotting
        
        u_solutions[k,:,:] = un



    ### Animation 
    
    # First set up the figure, the axis, and the plot element we want to animate
    fig = plt.figure()
    ax = plt.axes(xlim=(xmin,xmax), ylim=(np.min(un), np.max(un)*1.1))

    lines=[]     # list for plot lines for solvers and analytical solutions
    legends=[]   # list for legends for solvers and analytical solutions

    for solver in solvers:
        line, = ax.plot([], [])
        lines.append(line)
        legends.append(solver.__name__)
        
    legends.append('Analytical')

    line, = ax.plot([], []) #add extra plot line for analytical solution
    lines.append(line)

    plt.xlabel('x')
    plt.ylabel('u')
    plt.legend(legends, loc=3, frameon=False)
    
    def init():
        for line in lines:
            line.set_data([], [])
        return lines,

    # animation function.  This is called sequentially
    def animate(i):
        for k, line in enumerate(lines):
            if (k==0):
                line.set_data(x, un[i,:])
            else:
                line.set_data(x, uanalytical[i,:])
        return lines,

    def animate_alt(i):
        for k, line in enumerate(lines):
            if (k==len(lines)-1):
                line.set_data(x, uanalytical[i,:])
            else:
                line.set_data(x, u_solutions[k,i,:])
        return lines,

    
    # call the animator.  blit=True means only re-draw the parts that have changed.
    anim = matplotlib.animation.FuncAnimation(fig, animate_alt, init_func=init, frames=Nt, interval=100, blit=False)
    
    
    plt.show()