#!/usr/bin/env python3
# -*- coding: utf-8 -*-

""" Hyperbolic equations. Advection.

    This program solves the advection equation by applying various methods:
    FTCS, Lax-Wendroff, and Lax-Friedrichs and generates an animated plot
    showing the solutions generated by each one of them for certain initial
    conditions.
"""

import argparse

import matplotlib.animation
import matplotlib.pyplot as plt
import numpy as np
import scipy.interpolate

# Initial conditions ###########################################################

def initial_condition_stair_case(
        x: np.array
) -> np.array:

    """ Initial condition as a stair case function. """

    _f = np.zeros_like(x)
    _X_RIGHT = 0.1
    _f[np.where(x <= _X_RIGHT)] = 1.0
    return _f

def initial_condition_step(
        x: np.array
) -> np.array:

    """ Initial condition for a step function. """
    _f = np.zeros_like(x)
    _X_LEFT = 0.33
    _X_RIGHT = 0.66
    _f[np.where(x >= _X_LEFT * (np.max(x) - np.min(x)))] = 1.0
    _f[np.where(x >= _X_RIGHT * (np.max(x) - np.min(x)))] = 0.0
    return _f

def initial_condition_sin2(
        x: np.array
) -> np.array:

    """ Initial condition as the sin^2. """

    _f = np.zeros_like(x)
    _X_LEFT = 0.33
    _X_RIGHT = 0.66
    _f = np.where(
        (x > _X_LEFT) & (x < _X_RIGHT),
        np.sin(np.pi * (x - _X_LEFT) / (_X_RIGHT - _X_LEFT))**4, _f) 
    return _f

INITIAL_CONDITIONS = [
    initial_condition_stair_case,
    initial_condition_step,
    initial_condition_sin2
]

# Solvers ######################################################################

def ftcs(
        u: np.array,
        c: float
) -> np.array:

    """ FTCS solver.

    Args:
        u: Solution vector.
        c: Courant number.

    Returns:
        The solution vector for the next time step.
    """

    u[1:-1] = (1-c)*u[1:-1] + c*u[:-2]
    return u[1:-1]

def lax_wendroff(
        u: np.array,
        c: float
) -> np.array:

    """ Lax-Wendroff solver.

    Args:
        u: Solution vector.
        c: Courant number.

    Returns:
        The solution vector for the next time step.
    """

    u[1:-1] = c/2.0*(1+c)*u[:-2] + (1-c**2)*u[1:-1] - c/2.0*(1-c)*u[2:]
    return u[1:-1]

def lax_friedrich(
        u: np.array,
        c: float
) -> np.array:

    """ Lax-Friedrich solver.

    Args:
        u: Solution vector.
        c: Courant number.

    Returns:
        The solution vector for the next time step.
    """

    u[1:-1] = (u[:-2] +u[2:])/2.0 -  c*(u[2:] - u[:-2])/2.0
    return u[1:-1]

SOLVERS = [
  ftcs,
  lax_wendroff,
  lax_friedrich
]

SOLVERS_LABELS = [
  "FTCS",
  "Lax-Wendroff",
  "Lax-Friedrichs"
]

# ##############################################################################

if __name__ == "__main__":

    # Argument parsing ---------------------------------------------------------

    PARSER = argparse.ArgumentParser(description="Advection equation solver")
    PARSER.add_argument("--a", type=float, default=1.0, help="Wave speed")
    PARSER.add_argument("--tmin", type=float, default=0.0, help="Start time")
    PARSER.add_argument("--tmax", type=float, default=4.0, help="End time")
    PARSER.add_argument("--xmin", type=float, default=0.0, help="Spatial start")
    PARSER.add_argument("--xmax", type=float, default=4.0, help="Spatial end")
    PARSER.add_argument("--nx", type=int, default=128, help="Spatial points")
    PARSER.add_argument("--c", type=float, default=0.5, help="Courant number")
    PARSER.add_argument(
        "--i",
        type=int,
        default=2,
        help="Initial condition [0: stair, 1: step, 2: sin^2]")
    ARGS = PARSER.parse_args()

    A = ARGS.a
    T_MIN = ARGS.tmin
    T_MAX = ARGS.tmax
    X_MIN = ARGS.xmin
    X_MAX = ARGS.xmax
    NX = ARGS.nx
    C = ARGS.c
    INITIAL_CONDITION = ARGS.i

    # Space and time discretization --------------------------------------------

    # Compute the discretization of space (x), its corresponding step size (dx),
    # the time step size based on the stability condition (dt), the number of
    # time steps (NT), and then the time discretization (time).

    X = np.linspace(X_MIN, X_MAX, NX+1)
    DX = float((X_MAX - X_MIN) / NX)
    DT = C / A * DX
    NT = int((T_MAX - T_MIN) / DT)
    TIME = np.linspace(T_MIN, T_MAX, NT)

    # Solve the equation -------------------------------------------------------

    # Arrays to hold the solutions for each solver for each time and space step.
    _u_solutions = np.zeros((len(SOLVERS), len(TIME), len(X)))
    _u_analytical = np.zeros((len(TIME), len(X)))
    # Select the initial condition function
    _initial_condition_function = INITIAL_CONDITIONS[INITIAL_CONDITION]

    # Solve using each solver of the list.
    for k, solver in enumerate(SOLVERS):

        # Define the initial condition.
        _u = _initial_condition_function(X)
        # Array for storing the solution for each timestep.
        _un = np.zeros((len(TIME), len(X)))

        for i, t in enumerate(TIME[1:]):

            # Interplate at right boundary.
            _u_bc = scipy.interpolate.interp1d(X[-2:], _u[-2:]) 
            # Calculate numerical solution of interior.
            _u[1:-1] = solver(_u[:], C)
            # Interpolate along a characteristic to find the boundary value.
            _u[-1] = _u_bc(X[-1] - A * DT)
            # Store solution of the current timestep for later plotting.
            _un[i,:] = _u[:]

        # Store solution of the current solver for all timesteps.
        _u_solutions[k, :, :] = _un

    # Solve for the analytical case.
    _u = _initial_condition_function(X)
    for i, t in enumerate(TIME[1:]):
        _u_analytical[i,:] = _initial_condition_function(X - A * t)

    # Figure setup -------------------------------------------------------------

    # Set LaTeX font and appropriate sizes.
    matplotlib.rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    matplotlib.rc('text', usetex=True)
    plt.rc('font', size=24) # Controls default text sizes.
    plt.rc('axes', titlesize=32) # Fontsize of the axes title.
    plt.rc('axes', labelsize=24) # Fontsize of the x and y labels.
    plt.rc('xtick', labelsize=24) # Fontsize of the tick labels.
    plt.rc('ytick', labelsize=24) # Fontsize of the tick labels.
    plt.rc('legend', fontsize=24) # Legend fontsize.
    plt.rc('figure', titlesize=32) # Fontsize of the figure title.

    # Create figure and arrange axis.
    fig = plt.figure()
    ax = fig.add_subplot()
    ax.set_xlim([X_MIN, X_MAX])
    ax.set_ylim([np.min(_un) - 0.25 * np.max(_un), np.max(_un) * 1.25])

    # Lists of plot lines for solvers and analytical solutions.
    lines = []

    # Add one line for each solver and append their legends.
    for i, solver in enumerate(SOLVERS):
        line, = ax.plot([], [], label=SOLVERS_LABELS[i])
        lines.append(line)

    # Add one extra line for the analytical solution.
    line, = ax.plot([], [], label="Analytical")
    lines.append(line)

    # Label axes and legend.
    plt.xlabel(r"$x$")
    plt.ylabel(r"$u$")
    ax.legend(
        loc="upper center",
        bbox_to_anchor=(0.5, -0.05),
        fancybox=True,
        shadow=True,
        ncol=5
    )

    # Animation ----------------------------------------------------------------
    
    def init():

        """ Initialize all lines to empty. """

        for line in lines:
            line.set_data([], [])
        return lines,

    def animate(i):

        """ Update all lines and title with the current time step. """

        fig.suptitle("Timestep = " + str(i))

        for k, line in enumerate(lines):
            if (k == len(lines) - 1):
                line.set_data(X, _u_analytical[i,:])
            else:
                line.set_data(X, _u_solutions[k,i,:])
        return lines,

    anim = matplotlib.animation.FuncAnimation(
        fig,
        animate,
        init_func=init,
        frames=NT,
        interval=100,
        blit=False)
    plt.show()